c
updated_employee['first_name']
updateable_employee['first_name']
q
updated_employee['first_name']
updateable_employee['first_name']
updateable_employee['area'].first['id']
updateable_employee['area'].first
updated_employee['area']
updateable_employee['area']
q
expect(updateable_employee['area']).to_not(eq(updated_employee['area']))
expect(updated_employee).to(be_a(Hash))
updated_employee
q
employee['area']
employee['department']
employee
q
c
deleteable_device_id
c
described_class.delete(deleteable_device_id)
deleteable_device_id
c
expect(updateable_device['alias']).to_not(eq(updated_device['alias']))
updated_device
c
q
expect(updateable_area.area_name).to_not(eq(updated_area.area_name))
expect(updated_area).to(be_a(OpenStruct))
updated_area
updateable_area
c
updateable_area['area_name']
updated_area['area_name']
c
updated_area['area_name']
updateable_area['area_name']
updated_area
c
expect(updateable_area['area_name']).to_not(eq(updated_area['area_name']))
expect(updateable_area['area_name']).to_not(eq(updateable_area['area_name']))
expect(updated_area).to(be_a(Hash))
updated_area
updateable_area
c
expect(area.area_code).to(eq("10000"))
expect(area).to(be_a(OpenStruct))
area
expect(area['area_code']).to(eq(10000))
expect(area).to(be_a(Hash))
area
c
areas
c
areas
c
areas
c
areas
q
areas
q
areas['data']
c
expect(areas['data'].first).to(be_a(Hash))
expect(areas.keys).to(include('count', 'next', 'previous'))
areas.keys
expect(areas['data']).to(be_a(Array))
areas['data']
areas
q
area = described_class.show(1)
ZktClient.is_object_response_enabled = true
ZktClient.is_object_response_enabled = false
ZktClient.is_object_response_enabled
ZktClient
q
area
c
ZktClient.username
ZktClient.configure { |co| co.username = 'sdsd' }
ZktClient.configure do |e|
ZktClient.username
ZktClient.username = 'nil'
ZktClient.username
ZktClient.username = nil
ZktClient.username
ZktClient
c
expect(area).to(be_a(Hash))
area
q
c
response
c
response
c
response
c
response
c
!params[attribute].is_a?(klass_type)
!klass_type.nil?
klass_type
c
klass_type
c
klass_type
c
klass_type
c
klass_type
c
klass_type
q
klass_type
params[attribute].class.name == klass_type
params[attribute].class.name
params[attribute].class
klass_type
klass_type.present?
c
klass_type.present?
c
klass_type.present?
c
klass_type.present?
c
klass_type.present?
c
klass_type.present?
c
klass_type.present?
c
klass_type.present?
c
klass_type.present?
c
klass_type.present?
c
klass_type.present?
c
klass_type.present? && params[attribute].is_a?(klass_type)
klass_type = options[:type].to_s
q
klass_type = options[:type]
c
!options[:blank] && (params.has_key?(attribute) && params[attribute].blank?)
params.has_key?(attribute)
attribute
c
raise(ArgumentError, "#{attribute} is required")
options[:required] && !params.has_key?(attribute)
c
options[:required] && !params.has_key?(attribute)
attribute
c
options[:type].to_s.present?
options[:type]
options[:type].to_s.present? && !params[attribute]&.is_a?(options[:type])
c
options[:type].to_s.present? && !params[attribute]&.is_a?(options[:type])
c
options[:type].to_s.present? && !params[attribute]&.is_a?(options[:type])
c
options[:type].to_s.present? && !params[attribute]&.is_a?(options[:type])
c
options[:type].to_s.present? && !params[attribute]&.is_a?(options[:type])
c
options[:type].to_s.present? && !params[attribute]&.is_a?(options[:type])
c
options[:type].to_s.present? && !params[attribute]&.is_a?(options[:type])
c
options[:type].to_s.present? && !params[attribute]&.is_a?(options[:type])
c
options[:type].to_s.present? && !params[attribute]&.is_a?(options[:type])
c
options[:type].to_s.present? && !params[attribute]&.is_a?(options[:type])
c
options[:type].to_s.present? && !params[attribute]&.is_a?(options[:type])
c
options[:type].to_s.present? && !params[attribute]&.is_a?(options[:type])
options[:type].to_s.present?
c
options[:type].to_s.present?
options[:type].to_s
options[:type]
!params[attribute]&.is_a?(options[:type])
options[:type]
q
nil && !params[attribute].is_a?(options[:type])
options[:type] && !params[attribute].is_a?(options[:type])
options[:type]
options[:type].present?
options[:type]
c
options[:type]
c
options[:type]
c
options[:type]
c
options[:type]
c
options[:type]
c
params[attribute].to_s.present?
params[attribute].to_s
params[attribute]
params[attribute].present? && options[:in]&.exclude?(params[attribute])
c
params[attribute].present? && options[:in]&.exclude?(params[attribute])
params[attribute].present?
params[attribute]
options[:in]
attribute
params[attribute]
options[:in]
c
options[:in]
c
options[:in]
c
options[:in]&.exclude?(params[attribute])
options[:in]
c
options[:in]&.exclude?(params[attribute])
options[:in]
c
params.except(*self::REQUIRED_FEILDS)
self::REQUIRED_FEILDS
field
field.to_sym
c
url
c
url
c
!params.has_key?(attribute)
attribute
c
attribute
c
self::REQUIRED_FEILDS
self
c
!params.has_key?(attribute)
c
attribute
!params.has_key?(attribute)
options[:required] && !params.has_key?(attribute)
params
c
q
